<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>UseStringIsEmptyRule.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">qulice-maven-plugin</a> &gt; <a href="../index.html" class="el_bundle">qulice-pmd</a> &gt; <a href="index.source.html" class="el_package">com.qulice.pmd.rules</a> &gt; <span class="el_source">UseStringIsEmptyRule.java</span></div><h1>UseStringIsEmptyRule.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2011-2019, Qulice.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met: 1) Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer. 2) Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution. 3) Neither the name of the Qulice.com nor
 * the names of its contributors may be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.qulice.pmd.rules;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTName;
import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;
import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;
import net.sourceforge.pmd.lang.java.ast.ASTResultType;
import net.sourceforge.pmd.lang.java.rule.AbstractInefficientZeroCheck;
import net.sourceforge.pmd.lang.java.symboltable.ClassScope;
import net.sourceforge.pmd.lang.java.symboltable.JavaNameOccurrence;
import net.sourceforge.pmd.lang.java.symboltable.MethodNameDeclaration;
import net.sourceforge.pmd.lang.symboltable.NameOccurrence;
import net.sourceforge.pmd.util.StringUtil;

/**
 * Rule to prohibit use of String.length() when checking for empty string.
 * String.isEmpty() should be used instead.
 * @since 0.18
 * @todo #950:30min Correct this class so it  complains if the string is
 *  prefixed with this when length is called (e.g. somestring.length() works
 *  but this.somestring.length() does not). The same happens in with a method
 *  call (this.method().length() does not work). More about how to write PMD
 *  rules here: http://pmd.sourceforge.net/pmd-4.3/howtowritearule.html. Then
 *  ignore the tests on UseStringIsEmptyRuleTest.
 */
@SuppressWarnings(&quot;PMD.AvoidDuplicateLiterals&quot;)
<span class="nc" id="L61">public final class UseStringIsEmptyRule extends AbstractInefficientZeroCheck {</span>

    @Override
    public boolean appliesToClassName(final String name) {
<span class="nc" id="L65">        return StringUtil.isSame(name, &quot;String&quot;, true, true, true);</span>
    }

    @Override
    public Map&lt;String, List&lt;String&gt;&gt; getComparisonTargets() {
<span class="nc" id="L70">        final Map&lt;String, List&lt;String&gt;&gt; rules = new HashMap&lt;&gt;();</span>
<span class="nc" id="L71">        rules.put(&quot;&lt;&quot;, Arrays.asList(&quot;1&quot;));</span>
<span class="nc" id="L72">        rules.put(&quot;&gt;&quot;, Arrays.asList(&quot;0&quot;));</span>
<span class="nc" id="L73">        rules.put(&quot;==&quot;, Arrays.asList(&quot;0&quot;));</span>
<span class="nc" id="L74">        rules.put(&quot;!=&quot;, Arrays.asList(&quot;0&quot;));</span>
<span class="nc" id="L75">        rules.put(&quot;&gt;=&quot;, Arrays.asList(&quot;0&quot;, &quot;1&quot;));</span>
<span class="nc" id="L76">        rules.put(&quot;&lt;=&quot;, Arrays.asList(&quot;0&quot;));</span>
<span class="nc" id="L77">        return rules;</span>
    }

    @Override
    public boolean isTargetMethod(final JavaNameOccurrence occ) {
<span class="nc" id="L82">        boolean target = false;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (occ.getNameForWhichThisIsAQualifier() != null</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">            &amp;&amp; occ.getLocation().getImage().endsWith(&quot;.length&quot;)</span>
        ) {
<span class="nc" id="L86">            target = true;</span>
        }
<span class="nc" id="L88">        return target;</span>
    }

    @Override
    public Object visit(final ASTPrimarySuffix node, final Object data) {
<span class="nc bnc" id="L93" title="All 4 branches missed.">        if (node.getImage() != null &amp;&amp; node.getImage().endsWith(&quot;length&quot;)) {</span>
<span class="nc" id="L94">            ASTClassOrInterfaceType type = getTypeOfPrimaryPrefix(node);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L96">                type = getTypeOfMethodCall(node);</span>
            }
<span class="nc bnc" id="L98" title="All 2 branches missed.">            if (type != null</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">                &amp;&amp; this.appliesToClassName(type.getType().getSimpleName())</span>
            ) {
<span class="nc" id="L101">                checkNodeAndReport(</span>
<span class="nc" id="L102">                    data, node, node.jjtGetParent().jjtGetParent()</span>
                );
            }
        }
<span class="nc" id="L106">        return data;</span>
    }

    /**
     * Get the type returned by the method call.
     * @param node Node suffix
     * @return The type or null if it's not found
     */
    private static ASTClassOrInterfaceType getTypeOfMethodCall(
        final ASTPrimarySuffix node) {
<span class="nc" id="L116">        ASTClassOrInterfaceType type = null;</span>
<span class="nc" id="L117">        final ASTName method = node.jjtGetParent()</span>
<span class="nc" id="L118">            .getFirstChildOfType(ASTPrimaryPrefix.class)</span>
<span class="nc" id="L119">            .getFirstChildOfType(ASTName.class);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (method != null) {</span>
<span class="nc" id="L121">            final ClassScope scope = node.getScope()</span>
<span class="nc" id="L122">                .getEnclosingScope(ClassScope.class);</span>
<span class="nc" id="L123">            final Map&lt;MethodNameDeclaration, List&lt;NameOccurrence&gt;&gt; methods =</span>
<span class="nc" id="L124">                scope.getMethodDeclarations();</span>
            //@checkstyle LineLengthCheck (1 line)
            for (final Map.Entry&lt;MethodNameDeclaration, List&lt;NameOccurrence&gt;&gt; entry
<span class="nc bnc" id="L127" title="All 2 branches missed.">                : methods.entrySet()) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                if (entry.getKey().getName().equals(method.getImage())) {</span>
<span class="nc" id="L129">                    type = entry.getKey().getNode()</span>
<span class="nc" id="L130">                        .getFirstParentOfType(ASTMethodDeclaration.class)</span>
<span class="nc" id="L131">                        .getFirstChildOfType(ASTResultType.class)</span>
<span class="nc" id="L132">                        .getFirstDescendantOfType(</span>
                            ASTClassOrInterfaceType.class
                        );
<span class="nc" id="L135">                    break;</span>
                }
<span class="nc" id="L137">            }</span>
        }
<span class="nc" id="L139">        return type;</span>
    }

    /**
     * Get the type of the primary prefix.
     * @param node Node suffix
     * @return The type or null if it's not found.
     */
    private static ASTClassOrInterfaceType getTypeOfPrimaryPrefix(
        final ASTPrimarySuffix node) {
<span class="nc" id="L149">        return node.jjtGetParent()</span>
<span class="nc" id="L150">            .getFirstChildOfType(ASTPrimaryPrefix.class)</span>
<span class="nc" id="L151">            .getFirstDescendantOfType(ASTClassOrInterfaceType.class);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>